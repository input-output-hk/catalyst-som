-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE TABLE IF NOT EXISTS public.funds
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    title character varying COLLATE pg_catalog."default",
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT funds_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.funds
    OWNER to postgres;

ALTER TABLE IF EXISTS public.funds
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.funds TO anon;

GRANT ALL ON TABLE public.funds TO authenticated;

GRANT ALL ON TABLE public.funds TO postgres;

GRANT ALL ON TABLE public.funds TO service_role;
CREATE POLICY "Public select"
    ON public.funds
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TABLE IF NOT EXISTS public.users
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    user_id uuid,
    role bigint,
    created_at timestamp with time zone DEFAULT now(),
    username character varying COLLATE pg_catalog."default",
    email character varying COLLATE pg_catalog."default",
    _auth_user_id uuid,
    CONSTRAINT users_pkey PRIMARY KEY (id),
    CONSTRAINT users__auth_user_id_key UNIQUE (_auth_user_id),
    CONSTRAINT users_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.users
    OWNER to postgres;

ALTER TABLE IF EXISTS public.users
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.users TO anon;

GRANT ALL ON TABLE public.users TO authenticated;

GRANT ALL ON TABLE public.users TO postgres;

GRANT ALL ON TABLE public.users TO service_role;

CREATE OR REPLACE FUNCTION public.create_user()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
begin
  insert into public.users(user_id, _auth_user_id, email, role)
  values (new.id, new.id, new.email, 0);
  return new;
end;
$BODY$;

ALTER FUNCTION public.create_user()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.create_user() TO authenticated;

GRANT EXECUTE ON FUNCTION public.create_user() TO postgres;

GRANT EXECUTE ON FUNCTION public.create_user() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.create_user() TO anon;

GRANT EXECUTE ON FUNCTION public.create_user() TO service_role;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.create_user();

CREATE OR REPLACE FUNCTION public.can_access_users(
	_user_id uuid)
    RETURNS boolean
    LANGUAGE 'sql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$
SELECT EXISTS (
  SELECT 1
  FROM users u
  WHERE u.user_id = _user_id
  AND u.role >= 2
);
$BODY$;

ALTER FUNCTION public.can_access_users(uuid)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.can_access_users(uuid) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.can_access_users(uuid) TO anon;

GRANT EXECUTE ON FUNCTION public.can_access_users(uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION public.can_access_users(uuid) TO postgres;

GRANT EXECUTE ON FUNCTION public.can_access_users(uuid) TO service_role;

CREATE OR REPLACE FUNCTION public.is_admin(
	_user_id uuid)
    RETURNS boolean
    LANGUAGE 'sql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$
SELECT EXISTS (
  SELECT 1
  FROM users u
  WHERE u.user_id = _user_id
  AND u.role = 3
);
$BODY$;

ALTER FUNCTION public.is_admin(uuid)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.is_admin(uuid) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.is_admin(uuid) TO anon;

GRANT EXECUTE ON FUNCTION public.is_admin(uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION public.is_admin(uuid) TO postgres;

GRANT EXECUTE ON FUNCTION public.is_admin(uuid) TO service_role;


CREATE POLICY public
    ON public.users
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (((user_id = auth.uid()) OR can_access_users(auth.uid())));
CREATE POLICY "users update admin"
    ON public.users
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING (((user_id = auth.uid()) OR is_admin(auth.uid())));


CREATE TABLE IF NOT EXISTS public.challenges
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    title character varying COLLATE pg_catalog."default",
    created_at timestamp with time zone DEFAULT now(),
    fund_id bigint,
    CONSTRAINT challenges_pkey PRIMARY KEY (id),
    CONSTRAINT challenges_fund_id_fkey FOREIGN KEY (fund_id)
        REFERENCES public.funds (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.challenges
    OWNER to postgres;

ALTER TABLE IF EXISTS public.challenges
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.challenges TO anon;

GRANT ALL ON TABLE public.challenges TO authenticated;

GRANT ALL ON TABLE public.challenges TO postgres;

GRANT ALL ON TABLE public.challenges TO service_role;
CREATE POLICY "Public visible"
    ON public.challenges
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);


CREATE TABLE IF NOT EXISTS public.challenges_users
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    challenge_id bigint,
    user_id uuid,
    user_idd bigint,
    CONSTRAINT challenges_users_pkey PRIMARY KEY (id),
    CONSTRAINT challenges_users_challenge_id_fkey FOREIGN KEY (challenge_id)
        REFERENCES public.challenges (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT challenges_users_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT challenges_users_user_idd_fkey FOREIGN KEY (user_idd)
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.challenges_users
    OWNER to postgres;

ALTER TABLE IF EXISTS public.challenges_users
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.challenges_users TO authenticated;

GRANT ALL ON TABLE public.challenges_users TO anon;

GRANT ALL ON TABLE public.challenges_users TO service_role;

GRANT ALL ON TABLE public.challenges_users TO postgres;
CREATE POLICY "Create challenges_users"
    ON public.challenges_users
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK (is_admin(auth.uid()));
CREATE POLICY "Select public"
    ON public.challenges_users
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "delete admin"
    ON public.challenges_users
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((EXISTS ( SELECT users.user_id,
    users.role
   FROM users
  WHERE ((users.user_id = auth.uid()) AND (users.role = 3)))));


CREATE TABLE IF NOT EXISTS public.proposals
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    title character varying COLLATE pg_catalog."default",
    url character varying COLLATE pg_catalog."default",
    project_id bigint,
    completion_date timestamp without time zone,
    created_at timestamp with time zone DEFAULT now(),
    challenge_id bigint,
    budget bigint,
    funds_distributed bigint DEFAULT 0,
    CONSTRAINT proposals_pkey PRIMARY KEY (id),
    CONSTRAINT proposals_challenge_id_fkey FOREIGN KEY (challenge_id)
        REFERENCES public.challenges (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.proposals
    OWNER to postgres;

ALTER TABLE IF EXISTS public.proposals
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.proposals TO anon;

GRANT ALL ON TABLE public.proposals TO authenticated;

GRANT ALL ON TABLE public.proposals TO postgres;

GRANT ALL ON TABLE public.proposals TO service_role;
CREATE POLICY public
    ON public.proposals
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);


CREATE TABLE IF NOT EXISTS public.proposals_users
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    proposal_id bigint,
    user_id uuid,
    user_idd bigint,
    CONSTRAINT proposals_users_pkey PRIMARY KEY (id),
    CONSTRAINT proposals_users_proposal_id_fkey FOREIGN KEY (proposal_id)
        REFERENCES public.proposals (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT proposals_users_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT proposals_users_user_idd_fkey FOREIGN KEY (user_idd)
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.proposals_users
    OWNER to postgres;

ALTER TABLE IF EXISTS public.proposals_users
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.proposals_users TO authenticated;

GRANT ALL ON TABLE public.proposals_users TO anon;

GRANT ALL ON TABLE public.proposals_users TO service_role;

GRANT ALL ON TABLE public.proposals_users TO postgres;
CREATE POLICY "proposals_users delete"
    ON public.proposals_users
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING (is_admin(auth.uid()));
CREATE POLICY "proposals_users insert"
    ON public.proposals_users
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK (is_admin(auth.uid()));
CREATE POLICY "proposals_users select"
    ON public.proposals_users
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TABLE IF NOT EXISTS public.allocations
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    proposal_id bigint,
    user_id uuid,
    user_idd bigint,
    CONSTRAINT allocations_pkey PRIMARY KEY (id),
    CONSTRAINT allocations_proposal_id_fkey FOREIGN KEY (proposal_id)
        REFERENCES public.proposals (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT allocations_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT allocations_user_idd_fkey FOREIGN KEY (user_idd)
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.allocations
    OWNER to postgres;

ALTER TABLE IF EXISTS public.allocations
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.allocations TO authenticated;

GRANT ALL ON TABLE public.allocations TO anon;

GRANT ALL ON TABLE public.allocations TO service_role;

GRANT ALL ON TABLE public.allocations TO postgres;
CREATE POLICY "Allocations delete"
    ON public.allocations
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING (can_access_users(auth.uid()));
CREATE POLICY "Allocations insert"
    ON public.allocations
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK (can_access_users(auth.uid()));
CREATE POLICY "Allocations select"
    ON public.allocations
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);


CREATE TABLE IF NOT EXISTS public.soms
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    outputs text COLLATE pg_catalog."default",
    success_criteria text COLLATE pg_catalog."default",
    evidence text COLLATE pg_catalog."default",
    month text COLLATE pg_catalog."default",
    cost bigint,
    completion bigint,
    proposal_id bigint,
    created_at timestamp with time zone DEFAULT now(),
    milestone bigint,
    title character varying COLLATE pg_catalog."default",
    challenge_id bigint,
    current boolean DEFAULT false,
    user_id uuid DEFAULT auth.uid(),
    CONSTRAINT soms_pkey PRIMARY KEY (id),
    CONSTRAINT soms_challenge_id_fkey FOREIGN KEY (challenge_id)
        REFERENCES public.challenges (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT soms_proposal_id_fkey FOREIGN KEY (proposal_id)
        REFERENCES public.proposals (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT soms_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (_auth_user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.soms
    OWNER to postgres;

ALTER TABLE IF EXISTS public.soms
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.soms TO authenticated;

GRANT ALL ON TABLE public.soms TO anon;

GRANT ALL ON TABLE public.soms TO service_role;

GRANT ALL ON TABLE public.soms TO postgres;

CREATE OR REPLACE FUNCTION public.is_proposal_owner(
	_proposal_id bigint)
    RETURNS boolean
    LANGUAGE 'sql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$
SELECT EXISTS (
  SELECT 1
  FROM proposals_users pu
  WHERE pu.user_id = auth.uid()
  AND pu.proposal_id = _proposal_id
);
$BODY$;

ALTER FUNCTION public.is_proposal_owner(bigint)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.is_proposal_owner(bigint) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.is_proposal_owner(bigint) TO anon;

GRANT EXECUTE ON FUNCTION public.is_proposal_owner(bigint) TO authenticated;

GRANT EXECUTE ON FUNCTION public.is_proposal_owner(bigint) TO postgres;

GRANT EXECUTE ON FUNCTION public.is_proposal_owner(bigint) TO service_role;

CREATE POLICY "SoMs insert"
    ON public.soms
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((is_proposal_owner(proposal_id) OR is_admin(auth.uid())));
CREATE POLICY "SoMs update"
    ON public.soms
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((is_proposal_owner(proposal_id) OR is_admin(auth.uid())))
    WITH CHECK ((is_proposal_owner(proposal_id) OR is_admin(auth.uid())));
CREATE POLICY public
    ON public.soms
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);


CREATE OR REPLACE FUNCTION public.set_old_som_not_current()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
begin
  update public.soms
  set current=false
  where proposal_id = new.proposal_id
  and milestone = new.milestone
  and current
  and id != new.id;
  return new;
end;
$BODY$;

ALTER FUNCTION public.set_old_som_not_current()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.set_old_som_not_current() TO authenticated;

GRANT EXECUTE ON FUNCTION public.set_old_som_not_current() TO postgres;

GRANT EXECUTE ON FUNCTION public.set_old_som_not_current() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.set_old_som_not_current() TO anon;

GRANT EXECUTE ON FUNCTION public.set_old_som_not_current() TO service_role;

CREATE TRIGGER on_som_created
    BEFORE INSERT
    ON public.soms
    FOR EACH ROW
    EXECUTE FUNCTION public.set_old_som_not_current();


CREATE TABLE IF NOT EXISTS public.som_reviews
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    outputs_approves boolean,
    outputs_comment text COLLATE pg_catalog."default",
    success_criteria_approves boolean,
    success_criteria_comment text COLLATE pg_catalog."default",
    evidence_approves boolean,
    evidence_comment text COLLATE pg_catalog."default",
    som_id bigint,
    role bigint,
    created_at timestamp with time zone DEFAULT now(),
    challenge_id bigint,
    user_id uuid DEFAULT auth.uid(),
    CONSTRAINT som_reviews_pkey PRIMARY KEY (id),
    CONSTRAINT som_reviews_challenge_id_fkey FOREIGN KEY (challenge_id)
        REFERENCES public.challenges (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT som_reviews_som_id_fkey FOREIGN KEY (som_id)
        REFERENCES public.soms (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT som_reviews_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (_auth_user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.som_reviews
    OWNER to postgres;

ALTER TABLE IF EXISTS public.som_reviews
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.som_reviews TO authenticated;

GRANT ALL ON TABLE public.som_reviews TO anon;

GRANT ALL ON TABLE public.som_reviews TO service_role;

GRANT ALL ON TABLE public.som_reviews TO postgres;

CREATE OR REPLACE FUNCTION public.is_in_challenge_ct(
	_challenge_ids bigint[])
    RETURNS boolean
    LANGUAGE 'sql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$
SELECT EXISTS (
  SELECT cu.user_id
  FROM public.challenges_users cu
  WHERE (
    cu.user_id = auth.uid()
    AND cu.challenge_id = any (_challenge_ids)
  )
);
$BODY$;

ALTER FUNCTION public.is_in_challenge_ct(bigint[])
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.is_in_challenge_ct(bigint[]) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.is_in_challenge_ct(bigint[]) TO anon;

GRANT EXECUTE ON FUNCTION public.is_in_challenge_ct(bigint[]) TO authenticated;

GRANT EXECUTE ON FUNCTION public.is_in_challenge_ct(bigint[]) TO postgres;

GRANT EXECUTE ON FUNCTION public.is_in_challenge_ct(bigint[]) TO service_role;

CREATE OR REPLACE FUNCTION public.is_io_member(
	_user_id uuid)
    RETURNS boolean
    LANGUAGE 'sql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$
SELECT EXISTS (
  SELECT 1
  FROM users u
  WHERE u.user_id = _user_id
  AND u.role = 2
);
$BODY$;

ALTER FUNCTION public.is_io_member(uuid)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.is_io_member(uuid) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.is_io_member(uuid) TO anon;

GRANT EXECUTE ON FUNCTION public.is_io_member(uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION public.is_io_member(uuid) TO postgres;

GRANT EXECUTE ON FUNCTION public.is_io_member(uuid) TO service_role;

CREATE OR REPLACE FUNCTION public.is_proposal_allocated(
	_proposal_id bigint)
    RETURNS boolean
    LANGUAGE 'sql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$
SELECT EXISTS (
  SELECT 1
  FROM allocations a
  WHERE a.user_id = auth.uid()
  AND a.proposal_id = _proposal_id
);
$BODY$;

ALTER FUNCTION public.is_proposal_allocated(bigint)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.is_proposal_allocated(bigint) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.is_proposal_allocated(bigint) TO anon;

GRANT EXECUTE ON FUNCTION public.is_proposal_allocated(bigint) TO authenticated;

GRANT EXECUTE ON FUNCTION public.is_proposal_allocated(bigint) TO postgres;

GRANT EXECUTE ON FUNCTION public.is_proposal_allocated(bigint) TO service_role;

CREATE POLICY "Insert SoMs reviews"
    ON public.som_reviews
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((is_in_challenge_ct(( SELECT array_agg(soms.challenge_id) AS array_agg
   FROM soms
  WHERE (soms.id = som_reviews.som_id))) OR is_proposal_allocated(( SELECT soms.proposal_id
   FROM soms
  WHERE (soms.id = som_reviews.som_id))) OR is_io_member(auth.uid()) OR is_admin(auth.uid())));
CREATE POLICY public
    ON public.som_reviews
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);


CREATE OR REPLACE FUNCTION public.set_row_role()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
begin
  new.role := (select role from public.users where user_id = new.user_id);
  return new;
end;
$BODY$;

ALTER FUNCTION public.set_row_role()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.set_row_role() TO authenticated;

GRANT EXECUTE ON FUNCTION public.set_row_role() TO postgres;

GRANT EXECUTE ON FUNCTION public.set_row_role() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.set_row_role() TO anon;

GRANT EXECUTE ON FUNCTION public.set_row_role() TO service_role;

CREATE TRIGGER on_som_review_created
    BEFORE INSERT
    ON public.som_reviews
    FOR EACH ROW
    EXECUTE FUNCTION public.set_row_role();

CREATE TABLE IF NOT EXISTS public.poas
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    content text COLLATE pg_catalog."default",
    proposal_id bigint,
    created_at timestamp with time zone DEFAULT now(),
    som_id bigint,
    challenge_id bigint,
    current boolean DEFAULT false,
    user_id uuid DEFAULT auth.uid(),
    CONSTRAINT poas_pkey PRIMARY KEY (id),
    CONSTRAINT poas_challenge_id_fkey FOREIGN KEY (challenge_id)
        REFERENCES public.challenges (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT poas_proposal_id_fkey FOREIGN KEY (proposal_id)
        REFERENCES public.proposals (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT poas_som_id_fkey FOREIGN KEY (som_id)
        REFERENCES public.soms (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT poas_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (_auth_user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.poas
    OWNER to postgres;

ALTER TABLE IF EXISTS public.poas
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.poas TO authenticated;

GRANT ALL ON TABLE public.poas TO anon;

GRANT ALL ON TABLE public.poas TO service_role;

GRANT ALL ON TABLE public.poas TO postgres;
CREATE POLICY "PoAs insert"
    ON public.poas
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((is_proposal_owner(proposal_id) OR is_admin(auth.uid())));
CREATE POLICY "PoAs update"
    ON public.poas
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((is_proposal_owner(proposal_id) OR is_admin(auth.uid())))
    WITH CHECK ((is_proposal_owner(proposal_id) OR is_admin(auth.uid())));
CREATE POLICY public
    ON public.poas
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE OR REPLACE FUNCTION public.set_old_poa_not_current()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
begin
  update public.poas
  set current=false
  where som_id = new.som_id
  and current
  and id != new.id;
  return new;
end;
$BODY$;

ALTER FUNCTION public.set_old_poa_not_current()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.set_old_poa_not_current() TO authenticated;

GRANT EXECUTE ON FUNCTION public.set_old_poa_not_current() TO postgres;

GRANT EXECUTE ON FUNCTION public.set_old_poa_not_current() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.set_old_poa_not_current() TO anon;

GRANT EXECUTE ON FUNCTION public.set_old_poa_not_current() TO service_role;

CREATE TRIGGER on_poa_created
    BEFORE INSERT
    ON public.poas
    FOR EACH ROW
    EXECUTE FUNCTION public.set_old_poa_not_current();

CREATE TABLE IF NOT EXISTS public.signoffs
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    som_id bigint,
    poa_id bigint,
    created_at timestamp with time zone DEFAULT now(),
    user_id uuid DEFAULT auth.uid(),
    CONSTRAINT signoffs_pkey PRIMARY KEY (id),
    CONSTRAINT signoffs_poa_id_fkey FOREIGN KEY (poa_id)
        REFERENCES public.poas (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT signoffs_som_id_fkey FOREIGN KEY (som_id)
        REFERENCES public.soms (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT signoffs_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (_auth_user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.signoffs
    OWNER to postgres;

ALTER TABLE IF EXISTS public.signoffs
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.signoffs TO authenticated;

GRANT ALL ON TABLE public.signoffs TO anon;

GRANT ALL ON TABLE public.signoffs TO service_role;

GRANT ALL ON TABLE public.signoffs TO postgres;

CREATE OR REPLACE FUNCTION public.is_signoff_user(
	_user_id uuid)
    RETURNS boolean
    LANGUAGE 'sql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$
SELECT EXISTS (
  SELECT 1
  FROM users u
  WHERE u.user_id = _user_id
  AND u.role = 4
);
$BODY$;

ALTER FUNCTION public.is_signoff_user(uuid)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.is_signoff_user(uuid) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.is_signoff_user(uuid) TO anon;

GRANT EXECUTE ON FUNCTION public.is_signoff_user(uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION public.is_signoff_user(uuid) TO postgres;

GRANT EXECUTE ON FUNCTION public.is_signoff_user(uuid) TO service_role;

CREATE POLICY "Delete signoffs"
    ON public.signoffs
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((is_admin(auth.uid()) OR is_signoff_user(auth.uid())));
CREATE POLICY "Insert signoffs"
    ON public.signoffs
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((is_admin(auth.uid()) OR is_signoff_user(auth.uid())));
CREATE POLICY "Update signoffs"
    ON public.signoffs
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((is_admin(auth.uid()) OR is_signoff_user(auth.uid())))
    WITH CHECK ((is_admin(auth.uid()) OR is_signoff_user(auth.uid())));
CREATE POLICY public
    ON public.signoffs
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);











CREATE TABLE IF NOT EXISTS public.poas_reviews
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    content_approved boolean,
    content_comment text COLLATE pg_catalog."default",
    poas_id bigint,
    role bigint,
    created_at timestamp with time zone DEFAULT now(),
    user_id uuid DEFAULT auth.uid(),
    CONSTRAINT poas_review_pkey PRIMARY KEY (id),
    CONSTRAINT poas_reviews_poas_id_fkey FOREIGN KEY (poas_id)
        REFERENCES public.poas (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT poas_reviews_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (_auth_user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.poas_reviews
    OWNER to postgres;

ALTER TABLE IF EXISTS public.poas_reviews
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.poas_reviews TO anon;

GRANT ALL ON TABLE public.poas_reviews TO authenticated;

GRANT ALL ON TABLE public.poas_reviews TO postgres;

GRANT ALL ON TABLE public.poas_reviews TO service_role;
CREATE POLICY "Insert PoAs reviews"
    ON public.poas_reviews
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((is_in_challenge_ct(( SELECT array_agg(poas.challenge_id) AS array_agg
   FROM poas
  WHERE (poas.id = poas_reviews.poas_id))) OR is_proposal_allocated(( SELECT poas.proposal_id
   FROM poas
  WHERE (poas.id = poas_reviews.poas_id))) OR is_io_member(auth.uid()) OR is_admin(auth.uid())));
CREATE POLICY "Public list"
    ON public.poas_reviews
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TRIGGER on_poa_review_created
    BEFORE INSERT
    ON public.poas_reviews
    FOR EACH ROW
    EXECUTE FUNCTION public.set_row_role();









CREATE OR REPLACE FUNCTION public.getproposalsnapshot(
	_project_id bigint)
    RETURNS TABLE(title character varying, project_id bigint, budget bigint, funds_distributed bigint, id bigint, milestone bigint, month bigint, cost bigint, completion bigint, poas_id bigint, som_signoff_count bigint, poa_signoff_count bigint)
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
  BEGIN
    RETURN QUERY
      SELECT distinct on (soms.proposal_id, soms.milestone)
      proposals.title, proposals.project_id, proposals.budget,
      proposals.funds_distributed,
      soms.id, soms.milestone, CAST(soms.month as bigint), soms.cost, soms.completion,
      poas.id as poas_id,
      COUNT(ss.id) as som_signoff_count, COUNT(sp.id) as poa_signoff_count
      FROM soms
      LEFT OUTER JOIN proposals ON soms.proposal_id = proposals.id
      LEFT OUTER JOIN signoffs ss ON soms.id = ss.som_id
      LEFT OUTER JOIN poas ON soms.id = poas.som_id AND poas.current = true
      LEFT OUTER JOIN signoffs sp ON poas.id = sp.poa_id
      WHERE soms.current = true AND proposals.project_id = _project_id
      GROUP BY proposals.title, proposals.project_id, proposals.budget,
      proposals.funds_distributed, soms.id, soms.milestone, poas_id, poas.id
      ORDER BY soms.proposal_id ASC, soms.milestone ASC;
  end;
$BODY$;

ALTER FUNCTION public.getproposalsnapshot(bigint)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.getproposalsnapshot(bigint) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.getproposalsnapshot(bigint) TO anon;

GRANT EXECUTE ON FUNCTION public.getproposalsnapshot(bigint) TO authenticated;

GRANT EXECUTE ON FUNCTION public.getproposalsnapshot(bigint) TO postgres;

GRANT EXECUTE ON FUNCTION public.getproposalsnapshot(bigint) TO service_role;



CREATE OR REPLACE FUNCTION public.getallocatedsoms(
	)
    RETURNS TABLE(milestone bigint, proposal_id bigint, title character varying, created_at timestamp with time zone, project_id bigint, my_reviews_count bigint)
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    BEGIN
        RETURN QUERY
          SELECT
              soms.milestone,
              soms.proposal_id,
              soms.title,
              soms.created_at,
              proposals.project_id,
              count(distinct som_reviews.id) as my_reviews_count
              -- count(distinct signoffs.id) as signoffs_count
              FROM soms

                left join som_reviews
                  on som_reviews.som_id = soms.id
                  and som_reviews.user_id = auth.uid()
                left join
                  signoffs
                    on signoffs.som_id = soms.id
                left join
                  proposals
                    on proposals.id = soms.proposal_id
              where soms.proposal_id in (
                select allocations.proposal_id from allocations where allocations.user_id = auth.uid()
              )
              and soms.current = true
              group by soms.milestone, soms.proposal_id, soms.title, soms.created_at, proposals.project_id
              having count(distinct signoffs.id) = 0;
  END;
$BODY$;

ALTER FUNCTION public.getallocatedsoms()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.getallocatedsoms() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.getallocatedsoms() TO anon;

GRANT EXECUTE ON FUNCTION public.getallocatedsoms() TO authenticated;

GRANT EXECUTE ON FUNCTION public.getallocatedsoms() TO postgres;

GRANT EXECUTE ON FUNCTION public.getallocatedsoms() TO service_role;



CREATE OR REPLACE FUNCTION public.getmilestones(
	)
    RETURNS TABLE(title character varying, project_id bigint, budget bigint, id bigint, proposal_id bigint, milestone bigint)
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    BEGIN
        RETURN QUERY
            SELECT DISTINCT ON (soms.proposal_id, soms.milestone)
            proposals.title, proposals.project_id, proposals.budget,
            soms.id, soms.proposal_id, soms.milestone
            FROM soms
            LEFT OUTER JOIN proposals ON soms.proposal_id = proposals.id
            ORDER BY soms.proposal_id, soms.milestone, soms.created_at DESC;
    end;
$BODY$;

ALTER FUNCTION public.getmilestones()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.getmilestones() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.getmilestones() TO anon;

GRANT EXECUTE ON FUNCTION public.getmilestones() TO authenticated;

GRANT EXECUTE ON FUNCTION public.getmilestones() TO postgres;

GRANT EXECUTE ON FUNCTION public.getmilestones() TO service_role;



CREATE OR REPLACE FUNCTION public.getproposalssnapshot(
	)
    RETURNS TABLE(title character varying, project_id bigint, budget bigint, funds_distributed bigint, id bigint, milestone bigint, month bigint, cost bigint, completion bigint, poas_id bigint, som_signoff_count bigint, poa_signoff_count bigint)
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
  BEGIN
    RETURN QUERY
      SELECT distinct on (soms.proposal_id, soms.milestone)
      proposals.title, proposals.project_id, proposals.budget,
      proposals.funds_distributed,
      soms.id, soms.milestone, CAST(soms.month as bigint), soms.cost, soms.completion,
      poas.id as poas_id,
      COUNT(ss.id) as som_signoff_count, COUNT(sp.id) as poa_signoff_count
      FROM soms
      LEFT OUTER JOIN proposals ON soms.proposal_id = proposals.id
      LEFT OUTER JOIN signoffs ss ON soms.id = ss.som_id
      LEFT OUTER JOIN poas ON soms.id = poas.som_id AND poas.current = true
      LEFT OUTER JOIN signoffs sp ON poas.id = sp.poa_id
      WHERE soms.current = true
      GROUP BY proposals.title, proposals.project_id, proposals.budget,
      proposals.funds_distributed, soms.id, soms.milestone, poas_id, poas.id
      ORDER BY soms.proposal_id ASC, soms.milestone ASC;
  end;
$BODY$;

ALTER FUNCTION public.getproposalssnapshot()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.getproposalssnapshot() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.getproposalssnapshot() TO anon;

GRANT EXECUTE ON FUNCTION public.getproposalssnapshot() TO authenticated;

GRANT EXECUTE ON FUNCTION public.getproposalssnapshot() TO postgres;

GRANT EXECUTE ON FUNCTION public.getproposalssnapshot() TO service_role;



CREATE OR REPLACE FUNCTION public.getallocatedpoas(
	)
    RETURNS TABLE(milestone bigint, proposal_id bigint, title character varying, created_at timestamp with time zone, project_id bigint, my_reviews_count bigint)
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    BEGIN
        RETURN QUERY
          SELECT
              soms.milestone,
              soms.proposal_id,
              soms.title,
              poas.created_at,
              proposals.project_id,
              count(distinct poas_reviews.id) as my_reviews_count
              -- count(distinct signoffs.id) as signoffs_count
              FROM poas
                left join poas_reviews
                  on poas_reviews.poas_id = poas.id
                  and poas_reviews.user_id = auth.uid()
                left join
                  signoffs
                    on signoffs.poa_id = poas.id
                left join
                  soms
                    on soms.id = poas.som_id
                left join
                  proposals
                    on proposals.id = poas.proposal_id
              where poas.proposal_id in (
                select allocations.proposal_id from allocations where allocations.user_id = auth.uid()
              )
              and poas.current = true
              group by soms.milestone, soms.proposal_id, soms.title, poas.created_at, proposals.project_id
              having count(distinct signoffs.id) = 0;
  END;
$BODY$;

ALTER FUNCTION public.getallocatedpoas()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.getallocatedpoas() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.getallocatedpoas() TO anon;

GRANT EXECUTE ON FUNCTION public.getallocatedpoas() TO authenticated;

GRANT EXECUTE ON FUNCTION public.getallocatedpoas() TO postgres;

GRANT EXECUTE ON FUNCTION public.getallocatedpoas() TO service_role;


CREATE OR REPLACE FUNCTION public.getsignedoff(_date timestamp)
    RETURNS TABLE(poa_id bigint, som_id bigint, project_id bigint, title character varying, milestone bigint, poa_milestone bigint, created_at timestamp with time zone)
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    BEGIN
        RETURN QUERY
          select poas.id as poa_id, soms.id as som_id, proposals.project_id as project_id, proposals.title, soms.milestone, poa_soms.milestone as poa_milestone, signoffs.created_at from signoffs
          LEFT OUTER JOIN poas ON signoffs.poa_id = poas.id
          LEFT OUTER JOIN soms ON signoffs.som_id = soms.id
          LEFT OUTER JOIN soms as poa_soms ON poa_soms.id = poas.som_id
          LEFT OUTER JOIN proposals ON poas.proposal_id = proposals.id OR soms.proposal_id = proposals.id
          LEFT outer join proposals_users ON proposals_users.proposal_id = proposals.id
          where
          signoffs.created_at >= _date
          AND proposals_users.user_id = auth.uid();

  END;
$BODY$;

ALTER FUNCTION public.getsignedoff(timestamp)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.getsignedoff(timestamp) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.getsignedoff(timestamp) TO anon;

GRANT EXECUTE ON FUNCTION public.getsignedoff(timestamp) TO authenticated;

GRANT EXECUTE ON FUNCTION public.getsignedoff(timestamp) TO postgres;

GRANT EXECUTE ON FUNCTION public.getsignedoff(timestamp) TO service_role;
