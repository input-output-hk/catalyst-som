CREATE TABLE IF NOT EXISTS public.soms
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    outputs text COLLATE pg_catalog."default",
    success_criteria text COLLATE pg_catalog."default",
    evidence text COLLATE pg_catalog."default",
    month text COLLATE pg_catalog."default",
    cost bigint,
    completion bigint,
    proposal_id bigint,
    created_at timestamp with time zone DEFAULT now(),
    milestone bigint,
    title character varying COLLATE pg_catalog."default",
    challenge_id bigint,
    current boolean DEFAULT false,
    user_id uuid DEFAULT auth.uid(),
    CONSTRAINT soms_pkey PRIMARY KEY (id),
    CONSTRAINT soms_challenge_id_fkey FOREIGN KEY (challenge_id)
        REFERENCES public.challenges (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT soms_proposal_id_fkey FOREIGN KEY (proposal_id)
        REFERENCES public.proposals (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT soms_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (_auth_user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.soms
    OWNER to postgres;

ALTER TABLE IF EXISTS public.soms
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.soms TO authenticated;

GRANT ALL ON TABLE public.soms TO anon;

GRANT ALL ON TABLE public.soms TO service_role;

GRANT ALL ON TABLE public.soms TO postgres;

CREATE OR REPLACE FUNCTION public.is_proposal_owner(
	_proposal_id bigint)
    RETURNS boolean
    LANGUAGE 'sql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$
SELECT EXISTS (
  SELECT 1
  FROM proposals_users pu
  WHERE pu.user_id = auth.uid()
  AND pu.proposal_id = _proposal_id
);
$BODY$;

ALTER FUNCTION public.is_proposal_owner(bigint)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.is_proposal_owner(bigint) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.is_proposal_owner(bigint) TO anon;

GRANT EXECUTE ON FUNCTION public.is_proposal_owner(bigint) TO authenticated;

GRANT EXECUTE ON FUNCTION public.is_proposal_owner(bigint) TO postgres;

GRANT EXECUTE ON FUNCTION public.is_proposal_owner(bigint) TO service_role;

CREATE POLICY "SoMs insert"
    ON public.soms
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((is_proposal_owner(proposal_id) OR is_admin(auth.uid())));
CREATE POLICY "SoMs update"
    ON public.soms
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((is_proposal_owner(proposal_id) OR is_admin(auth.uid())))
    WITH CHECK ((is_proposal_owner(proposal_id) OR is_admin(auth.uid())));
CREATE POLICY public
    ON public.soms
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);


CREATE OR REPLACE FUNCTION public.set_old_som_not_current()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
begin
  update public.soms
  set current=false
  where proposal_id = new.proposal_id
  and milestone = new.milestone
  and current
  and id != new.id;
  return new;
end;
$BODY$;

ALTER FUNCTION public.set_old_som_not_current()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.set_old_som_not_current() TO authenticated;

GRANT EXECUTE ON FUNCTION public.set_old_som_not_current() TO postgres;

GRANT EXECUTE ON FUNCTION public.set_old_som_not_current() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.set_old_som_not_current() TO anon;

GRANT EXECUTE ON FUNCTION public.set_old_som_not_current() TO service_role;

CREATE TRIGGER on_som_created
    BEFORE INSERT
    ON public.soms
    FOR EACH ROW
    EXECUTE FUNCTION public.set_old_som_not_current();