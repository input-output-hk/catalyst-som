CREATE TABLE IF NOT EXISTS public.signoffs
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    som_id bigint,
    poa_id bigint,
    created_at timestamp with time zone DEFAULT now(),
    user_id uuid DEFAULT auth.uid(),
    CONSTRAINT signoffs_pkey PRIMARY KEY (id),
    CONSTRAINT signoffs_poa_id_fkey FOREIGN KEY (poa_id)
        REFERENCES public.poas (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT signoffs_som_id_fkey FOREIGN KEY (som_id)
        REFERENCES public.soms (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT signoffs_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (_auth_user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.signoffs
    OWNER to postgres;

ALTER TABLE IF EXISTS public.signoffs
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.signoffs TO authenticated;

GRANT ALL ON TABLE public.signoffs TO anon;

GRANT ALL ON TABLE public.signoffs TO service_role;

GRANT ALL ON TABLE public.signoffs TO postgres;

CREATE OR REPLACE FUNCTION public.is_signoff_user(
	_user_id uuid)
    RETURNS boolean
    LANGUAGE 'sql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$
SELECT EXISTS (
  SELECT 1
  FROM users u
  WHERE u.user_id = _user_id
  AND u.role = 4
);
$BODY$;

ALTER FUNCTION public.is_signoff_user(uuid)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.is_signoff_user(uuid) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.is_signoff_user(uuid) TO anon;

GRANT EXECUTE ON FUNCTION public.is_signoff_user(uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION public.is_signoff_user(uuid) TO postgres;

GRANT EXECUTE ON FUNCTION public.is_signoff_user(uuid) TO service_role;

CREATE POLICY "Delete signoffs"
    ON public.signoffs
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((is_admin(auth.uid()) OR is_signoff_user(auth.uid())));
CREATE POLICY "Insert signoffs"
    ON public.signoffs
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((is_admin(auth.uid()) OR is_signoff_user(auth.uid())));
CREATE POLICY "Update signoffs"
    ON public.signoffs
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((is_admin(auth.uid()) OR is_signoff_user(auth.uid())))
    WITH CHECK ((is_admin(auth.uid()) OR is_signoff_user(auth.uid())));
CREATE POLICY public
    ON public.signoffs
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);