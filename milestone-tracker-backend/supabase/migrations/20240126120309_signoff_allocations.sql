create table "public"."allocations_signoff" (
    "id" bigint generated by default as identity not null,
    "proposal_id" bigint,
    "user_id" uuid,
    "user_idd" bigint
);


alter table "public"."allocations_signoff" enable row level security;

CREATE UNIQUE INDEX signoff_allocations_pkey ON public.allocations_signoff USING btree (id);

alter table "public"."allocations_signoff" add constraint "signoff_allocations_pkey" PRIMARY KEY using index "signoff_allocations_pkey";

alter table "public"."allocations_signoff" add constraint "allocations_signoff_proposal_id_fkey" FOREIGN KEY (proposal_id) REFERENCES proposals(id) not valid;

alter table "public"."allocations_signoff" validate constraint "allocations_signoff_proposal_id_fkey";

alter table "public"."allocations_signoff" add constraint "allocations_signoff_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."allocations_signoff" validate constraint "allocations_signoff_user_id_fkey";

alter table "public"."allocations_signoff" add constraint "allocations_signoff_user_idd_fkey" FOREIGN KEY (user_idd) REFERENCES users(id) not valid;

alter table "public"."allocations_signoff" validate constraint "allocations_signoff_user_idd_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.is_proposal_allocated_for_signoff(_proposal_id bigint)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
SELECT EXISTS (
  SELECT 1
  FROM allocations_signoff a
  WHERE a.user_id = auth.uid()
  AND a.proposal_id = _proposal_id
);
$function$
;

grant delete on table "public"."allocations_signoff" to "anon";

grant insert on table "public"."allocations_signoff" to "anon";

grant references on table "public"."allocations_signoff" to "anon";

grant select on table "public"."allocations_signoff" to "anon";

grant trigger on table "public"."allocations_signoff" to "anon";

grant truncate on table "public"."allocations_signoff" to "anon";

grant update on table "public"."allocations_signoff" to "anon";

grant delete on table "public"."allocations_signoff" to "authenticated";

grant insert on table "public"."allocations_signoff" to "authenticated";

grant references on table "public"."allocations_signoff" to "authenticated";

grant select on table "public"."allocations_signoff" to "authenticated";

grant trigger on table "public"."allocations_signoff" to "authenticated";

grant truncate on table "public"."allocations_signoff" to "authenticated";

grant update on table "public"."allocations_signoff" to "authenticated";

grant delete on table "public"."allocations_signoff" to "service_role";

grant insert on table "public"."allocations_signoff" to "service_role";

grant references on table "public"."allocations_signoff" to "service_role";

grant select on table "public"."allocations_signoff" to "service_role";

grant trigger on table "public"."allocations_signoff" to "service_role";

grant truncate on table "public"."allocations_signoff" to "service_role";

grant update on table "public"."allocations_signoff" to "service_role";

create policy "admin  roles"
on "public"."allocations_signoff"
as permissive
for delete
to public
using (can_access_users(auth.uid()));


create policy "admin roles"
on "public"."allocations_signoff"
as permissive
for insert
to public
with check (can_access_users(auth.uid()));


create policy "public"
on "public"."allocations_signoff"
as permissive
for select
to public
using (true);



