CREATE TABLE IF NOT EXISTS public.som_reviews
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    outputs_approves boolean,
    outputs_comment text COLLATE pg_catalog."default",
    success_criteria_approves boolean,
    success_criteria_comment text COLLATE pg_catalog."default",
    evidence_approves boolean,
    evidence_comment text COLLATE pg_catalog."default",
    current boolean DEFAULT false,
    som_id bigint,
    role bigint,
    created_at timestamp with time zone DEFAULT now(),
    challenge_id bigint,
    user_id uuid DEFAULT auth.uid(),
    CONSTRAINT som_reviews_pkey PRIMARY KEY (id),
    CONSTRAINT som_reviews_challenge_id_fkey FOREIGN KEY (challenge_id)
        REFERENCES public.challenges (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT som_reviews_som_id_fkey FOREIGN KEY (som_id)
        REFERENCES public.soms (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT som_reviews_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (_auth_user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.som_reviews
    OWNER to postgres;

ALTER TABLE IF EXISTS public.som_reviews
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.som_reviews TO authenticated;

GRANT ALL ON TABLE public.som_reviews TO anon;

GRANT ALL ON TABLE public.som_reviews TO service_role;

GRANT ALL ON TABLE public.som_reviews TO postgres;

CREATE OR REPLACE FUNCTION public.set_old_som_reviews_not_current()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
begin
  update public.som_reviews
  set current=false
  where som_id = new.som_id
  and user_id = new.user_id
  and current
  and id != new.id;
  return new;
end;
$BODY$;

ALTER FUNCTION public.set_old_som_reviews_not_current()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.set_old_som_reviews_not_current() TO authenticated;

GRANT EXECUTE ON FUNCTION public.set_old_som_reviews_not_current() TO postgres;

GRANT EXECUTE ON FUNCTION public.set_old_som_reviews_not_current() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.set_old_som_reviews_not_current() TO anon;

GRANT EXECUTE ON FUNCTION public.set_old_som_reviews_not_current() TO service_role;

CREATE TRIGGER on_som_reviews_created
    BEFORE INSERT
    ON public.som_reviews
    FOR EACH ROW
    EXECUTE FUNCTION public.set_old_som_reviews_not_current();

CREATE OR REPLACE FUNCTION public.is_in_challenge_ct(
	_challenge_ids bigint[])
    RETURNS boolean
    LANGUAGE 'sql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$
SELECT EXISTS (
  SELECT cu.user_id
  FROM public.challenges_users cu
  WHERE (
    cu.user_id = auth.uid()
    AND cu.challenge_id = any (_challenge_ids)
  )
);
$BODY$;

ALTER FUNCTION public.is_in_challenge_ct(bigint[])
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.is_in_challenge_ct(bigint[]) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.is_in_challenge_ct(bigint[]) TO anon;

GRANT EXECUTE ON FUNCTION public.is_in_challenge_ct(bigint[]) TO authenticated;

GRANT EXECUTE ON FUNCTION public.is_in_challenge_ct(bigint[]) TO postgres;

GRANT EXECUTE ON FUNCTION public.is_in_challenge_ct(bigint[]) TO service_role;

CREATE OR REPLACE FUNCTION public.is_io_member(
	_user_id uuid)
    RETURNS boolean
    LANGUAGE 'sql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$
SELECT EXISTS (
  SELECT 1
  FROM users u
  WHERE u.user_id = _user_id
  AND u.role = 2
);
$BODY$;

ALTER FUNCTION public.is_io_member(uuid)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.is_io_member(uuid) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.is_io_member(uuid) TO anon;

GRANT EXECUTE ON FUNCTION public.is_io_member(uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION public.is_io_member(uuid) TO postgres;

GRANT EXECUTE ON FUNCTION public.is_io_member(uuid) TO service_role;

CREATE OR REPLACE FUNCTION public.is_proposal_allocated(
	_proposal_id bigint)
    RETURNS boolean
    LANGUAGE 'sql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$
SELECT EXISTS (
  SELECT 1
  FROM allocations a
  WHERE a.user_id = auth.uid()
  AND a.proposal_id = _proposal_id
);
$BODY$;

ALTER FUNCTION public.is_proposal_allocated(bigint)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.is_proposal_allocated(bigint) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.is_proposal_allocated(bigint) TO anon;

GRANT EXECUTE ON FUNCTION public.is_proposal_allocated(bigint) TO authenticated;

GRANT EXECUTE ON FUNCTION public.is_proposal_allocated(bigint) TO postgres;

GRANT EXECUTE ON FUNCTION public.is_proposal_allocated(bigint) TO service_role;

CREATE POLICY "Insert SoMs reviews"
    ON public.som_reviews
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((is_in_challenge_ct(( SELECT array_agg(soms.challenge_id) AS array_agg
   FROM soms
  WHERE (soms.id = som_reviews.som_id))) OR is_proposal_allocated(( SELECT soms.proposal_id
   FROM soms
  WHERE (soms.id = som_reviews.som_id))) OR is_io_member(auth.uid()) OR is_admin(auth.uid())));

CREATE POLICY "Update SoMs reviews"
    ON public.som_reviews
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((is_in_challenge_ct(( SELECT array_agg(soms.challenge_id) AS array_agg
   FROM soms
  WHERE (soms.id = som_reviews.som_id))) OR is_proposal_allocated(( SELECT soms.proposal_id
   FROM soms
  WHERE (soms.id = som_reviews.som_id))) OR is_io_member(auth.uid()) OR is_admin(auth.uid())))
    WITH CHECK ((is_in_challenge_ct(( SELECT array_agg(soms.challenge_id) AS array_agg
   FROM soms
  WHERE (soms.id = som_reviews.som_id))) OR is_proposal_allocated(( SELECT soms.proposal_id
   FROM soms
  WHERE (soms.id = som_reviews.som_id))) OR is_io_member(auth.uid()) OR is_admin(auth.uid())));


CREATE POLICY public
    ON public.som_reviews
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);


CREATE OR REPLACE FUNCTION public.set_row_role()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
begin
  new.role := (select role from public.users where user_id = new.user_id);
  return new;
end;
$BODY$;

ALTER FUNCTION public.set_row_role()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.set_row_role() TO authenticated;

GRANT EXECUTE ON FUNCTION public.set_row_role() TO postgres;

GRANT EXECUTE ON FUNCTION public.set_row_role() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.set_row_role() TO anon;

GRANT EXECUTE ON FUNCTION public.set_row_role() TO service_role;

CREATE TRIGGER on_som_review_created
    BEFORE INSERT
    ON public.som_reviews
    FOR EACH ROW
    EXECUTE FUNCTION public.set_row_role();