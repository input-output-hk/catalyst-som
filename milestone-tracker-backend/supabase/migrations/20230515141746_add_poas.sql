CREATE TABLE IF NOT EXISTS public.poas
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    content text COLLATE pg_catalog."default",
    proposal_id bigint,
    created_at timestamp with time zone DEFAULT now(),
    som_id bigint,
    challenge_id bigint,
    current boolean DEFAULT false,
    user_id uuid DEFAULT auth.uid(),
    CONSTRAINT poas_pkey PRIMARY KEY (id),
    CONSTRAINT poas_challenge_id_fkey FOREIGN KEY (challenge_id)
        REFERENCES public.challenges (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT poas_proposal_id_fkey FOREIGN KEY (proposal_id)
        REFERENCES public.proposals (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT poas_som_id_fkey FOREIGN KEY (som_id)
        REFERENCES public.soms (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT poas_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (_auth_user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.poas
    OWNER to postgres;

ALTER TABLE IF EXISTS public.poas
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.poas TO authenticated;

GRANT ALL ON TABLE public.poas TO anon;

GRANT ALL ON TABLE public.poas TO service_role;

GRANT ALL ON TABLE public.poas TO postgres;
CREATE POLICY "PoAs insert"
    ON public.poas
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((is_proposal_owner(proposal_id) OR is_admin(auth.uid())));
CREATE POLICY "PoAs update"
    ON public.poas
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((is_proposal_owner(proposal_id) OR is_admin(auth.uid())))
    WITH CHECK ((is_proposal_owner(proposal_id) OR is_admin(auth.uid())));
CREATE POLICY public
    ON public.poas
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE OR REPLACE FUNCTION public.set_old_poa_not_current()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
begin
  update public.poas
  set current=false
  where som_id = new.som_id
  and current
  and id != new.id;
  return new;
end;
$BODY$;

ALTER FUNCTION public.set_old_poa_not_current()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.set_old_poa_not_current() TO authenticated;

GRANT EXECUTE ON FUNCTION public.set_old_poa_not_current() TO postgres;

GRANT EXECUTE ON FUNCTION public.set_old_poa_not_current() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.set_old_poa_not_current() TO anon;

GRANT EXECUTE ON FUNCTION public.set_old_poa_not_current() TO service_role;

CREATE TRIGGER on_poa_created
    BEFORE INSERT
    ON public.poas
    FOR EACH ROW
    EXECUTE FUNCTION public.set_old_poa_not_current();